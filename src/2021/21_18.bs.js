// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var AoC = require("../AoC.bs.js");
var Curry = require("rescript/lib/js/curry.js");
var Tools = require("../Tools.bs.js");
var Js_json = require("rescript/lib/js/js_json.js");
var Caml_obj = require("rescript/lib/js/caml_obj.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Caml_splice_call = require("rescript/lib/js/caml_splice_call.js");

function mapTree(depthOpt, tree, f, g) {
  var depth = depthOpt !== undefined ? depthOpt : 0;
  if (tree.TAG === /* Leaf */0) {
    return Curry._2(f, depth, tree._0);
  } else {
    return Curry._3(g, depth, mapTree(depth + 1 | 0, tree._0, f, g), mapTree(depth + 1 | 0, tree._1, f, g));
  }
}

function mapLeftMost(tree, f) {
  if (tree.TAG === /* Leaf */0) {
    return {
            TAG: /* Leaf */0,
            _0: Curry._1(f, tree._0)
          };
  } else {
    return {
            TAG: /* Node */1,
            _0: mapLeftMost(tree._0, f),
            _1: tree._1
          };
  }
}

function mapRightMost(tree, f) {
  if (tree.TAG === /* Leaf */0) {
    return {
            TAG: /* Leaf */0,
            _0: Curry._1(f, tree._0)
          };
  } else {
    return {
            TAG: /* Node */1,
            _0: tree._0,
            _1: mapRightMost(tree._1, f)
          };
  }
}

function toString(number) {
  return mapTree(undefined, number, (function (param, x) {
                return x.toString();
              }), (function (param, l, r) {
                return "[" + l + "," + r + "]";
              }));
}

function magnitude(number) {
  return mapTree(undefined, number, (function (param, x) {
                return x;
              }), (function (param, l, r) {
                return Math.imul(l, 3) + (r << 1) | 0;
              }));
}

function explode(number) {
  var match = mapTree(undefined, number, (function (param, x) {
          return {
                  TAG: /* Reg */1,
                  _0: {
                    TAG: /* Leaf */0,
                    _0: x
                  }
                };
        }), (function (d, l, r) {
          var meta;
          var r$p;
          if (l.TAG === /* Exploded */0) {
            meta = l;
            r$p = r.TAG === /* Exploded */0 ? r.orig : r._0;
          } else {
            var l$p = l._0;
            var exit = 0;
            if (l$p.TAG === /* Leaf */0) {
              var l$p$1 = l$p._0;
              if (r.TAG === /* Exploded */0) {
                exit = 2;
              } else {
                var r$p$1 = r._0;
                if (r$p$1.TAG === /* Leaf */0) {
                  if (d >= 4) {
                    var r$p$2 = r$p$1._0;
                    return {
                            TAG: /* Exploded */0,
                            mod: {
                              TAG: /* Leaf */0,
                              _0: 0
                            },
                            orig: {
                              TAG: /* Node */1,
                              _0: {
                                TAG: /* Leaf */0,
                                _0: l$p$1
                              },
                              _1: {
                                TAG: /* Leaf */0,
                                _0: r$p$2
                              }
                            },
                            l: l$p$1,
                            r: r$p$2
                          };
                  }
                  exit = 2;
                } else {
                  exit = 2;
                }
              }
            } else {
              exit = 2;
            }
            if (exit === 2) {
              if (r.TAG !== /* Exploded */0) {
                return {
                        TAG: /* Reg */1,
                        _0: {
                          TAG: /* Node */1,
                          _0: l$p,
                          _1: r._0
                        }
                      };
              }
              var orig$p_1 = r.orig;
              var orig$p = {
                TAG: /* Node */1,
                _0: l$p,
                _1: orig$p_1
              };
              var x = r.l;
              if (x !== undefined) {
                return {
                        TAG: /* Exploded */0,
                        mod: {
                          TAG: /* Node */1,
                          _0: mapRightMost(l$p, (function (v) {
                                  return v + x | 0;
                                })),
                          _1: r.mod
                        },
                        orig: orig$p,
                        l: undefined,
                        r: r.r
                      };
              } else {
                return {
                        TAG: /* Exploded */0,
                        mod: {
                          TAG: /* Node */1,
                          _0: l$p,
                          _1: r.mod
                        },
                        orig: orig$p,
                        l: r.l,
                        r: r.r
                      };
              }
            }
            
          }
          var orig$p_0 = meta.orig;
          var orig$p$1 = {
            TAG: /* Node */1,
            _0: orig$p_0,
            _1: r$p
          };
          var x$1 = meta.r;
          if (x$1 !== undefined) {
            return {
                    TAG: /* Exploded */0,
                    mod: {
                      TAG: /* Node */1,
                      _0: meta.mod,
                      _1: mapLeftMost(r$p, (function (v) {
                              return v + x$1 | 0;
                            }))
                    },
                    orig: orig$p$1,
                    l: meta.l,
                    r: undefined
                  };
          } else {
            return {
                    TAG: /* Exploded */0,
                    mod: {
                      TAG: /* Node */1,
                      _0: meta.mod,
                      _1: r$p
                    },
                    orig: orig$p$1,
                    l: meta.l,
                    r: meta.r
                  };
          }
        }));
  if (match.TAG === /* Exploded */0) {
    return match.mod;
  }
  
}

function splitNumber(number) {
  var match = mapTree(undefined, number, (function (param, x) {
          if (x > 9) {
            return {
                    TAG: /* Split */0,
                    mod: {
                      TAG: /* Node */1,
                      _0: {
                        TAG: /* Leaf */0,
                        _0: Math.floor(x / 2) | 0
                      },
                      _1: {
                        TAG: /* Leaf */0,
                        _0: Math.ceil(x / 2) | 0
                      }
                    },
                    orig: {
                      TAG: /* Leaf */0,
                      _0: x
                    }
                  };
          } else {
            return {
                    TAG: /* Reg */1,
                    _0: {
                      TAG: /* Leaf */0,
                      _0: x
                    }
                  };
          }
        }), (function (param, l, r) {
          var mod;
          var orig;
          var r$p;
          if (l.TAG === /* Split */0) {
            var orig$1 = l.orig;
            var mod$1 = l.mod;
            mod = mod$1;
            orig = orig$1;
            r$p = r.TAG === /* Split */0 ? r.orig : r._0;
          } else {
            var l$p = l._0;
            if (r.TAG === /* Split */0) {
              return {
                      TAG: /* Split */0,
                      mod: {
                        TAG: /* Node */1,
                        _0: l$p,
                        _1: r.mod
                      },
                      orig: {
                        TAG: /* Node */1,
                        _0: l$p,
                        _1: r.orig
                      }
                    };
            } else {
              return {
                      TAG: /* Reg */1,
                      _0: {
                        TAG: /* Node */1,
                        _0: l$p,
                        _1: r._0
                      }
                    };
            }
          }
          return {
                  TAG: /* Split */0,
                  mod: {
                    TAG: /* Node */1,
                    _0: mod,
                    _1: r$p
                  },
                  orig: {
                    TAG: /* Node */1,
                    _0: orig,
                    _1: r$p
                  }
                };
        }));
  if (match.TAG === /* Split */0) {
    return match.mod;
  }
  
}

function reduceNumber(_number) {
  while(true) {
    var number = _number;
    var number$p = explode(number);
    if (number$p !== undefined) {
      _number = number$p;
      continue ;
    }
    var number$p$1 = splitNumber(number);
    if (number$p$1 === undefined) {
      return number;
    }
    _number = number$p$1;
    continue ;
  };
}

function parse(json) {
  var n = Js_json.classify(json);
  if (typeof n !== "number") {
    switch (n.TAG | 0) {
      case /* JSONNumber */1 :
          return {
                  TAG: /* Leaf */0,
                  _0: n._0 | 0
                };
      case /* JSONArray */3 :
          var match = n._0;
          if (match.length === 2) {
            var a = match[0];
            var b = match[1];
            return {
                    TAG: /* Node */1,
                    _0: parse(a),
                    _1: parse(b)
                  };
          }
          break;
      default:
        
    }
  }
  return Pervasives.failwith("Not a Snailfish Number: " + JSON.stringify(json));
}

AoC.getInput("2021", "18", (function (input_) {
        var input = Tools.lines(input_).map(function (line) {
              return parse(JSON.parse(line));
            });
        console.log(magnitude(Tools.reduce(Tools.rest(input), Tools.exn(Tools.$$Array.get(input, 0)), (function (a, b) {
                        return reduceNumber({
                                    TAG: /* Node */1,
                                    _0: a,
                                    _1: b
                                  });
                      }))));
        console.log(Caml_splice_call.spliceApply(Math.max, [input.map(function (x) {
                          return Tools.filterMap(input, (function (y) {
                                        if (Caml_obj.caml_equal(y, x)) {
                                          return ;
                                        } else {
                                          return magnitude(reduceNumber({
                                                          TAG: /* Node */1,
                                                          _0: x,
                                                          _1: y
                                                        }));
                                        }
                                      }));
                        }).flat()]));
        
      }));

exports.mapTree = mapTree;
exports.mapLeftMost = mapLeftMost;
exports.mapRightMost = mapRightMost;
exports.toString = toString;
exports.magnitude = magnitude;
exports.explode = explode;
exports.splitNumber = splitNumber;
exports.reduceNumber = reduceNumber;
exports.parse = parse;
/*  Not a pure module */
