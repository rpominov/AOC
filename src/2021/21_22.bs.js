// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var AoC = require("../AoC.bs.js");
var Curry = require("rescript/lib/js/curry.js");
var Tools = require("../Tools.bs.js");
var Point3d = require("../Point3d.bs.js");
var Belt_Set = require("rescript/lib/js/belt_Set.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Caml_option = require("rescript/lib/js/caml_option.js");

function split1d(low, high, splitBy) {
  if (splitBy < low) {
    return {
            TAG: /* Right */1,
            _0: [
              low,
              high
            ]
          };
  } else if (splitBy >= high) {
    return {
            TAG: /* Left */0,
            _0: [
              low,
              high
            ]
          };
  } else {
    return {
            TAG: /* Both */2,
            _0: [
              low,
              splitBy
            ],
            _1: [
              splitBy + 1 | 0,
              high
            ]
          };
  }
}

function partition1d(low, high, toSepLow, toSepHigh, f) {
  var inc = split1d(low, high, toSepLow - 1 | 0);
  switch (inc.TAG | 0) {
    case /* Left */0 :
        return [
                [Curry._1(f, inc._0)],
                undefined
              ];
    case /* Right */1 :
        var match = inc._0;
        var exc = split1d(match[0], match[1], toSepHigh);
        switch (exc.TAG | 0) {
          case /* Left */0 :
              return [
                      [],
                      Caml_option.some(Curry._1(f, exc._0))
                    ];
          case /* Right */1 :
              return [
                      [Curry._1(f, exc._0)],
                      undefined
                    ];
          case /* Both */2 :
              return [
                      [Curry._1(f, exc._1)],
                      Caml_option.some(Curry._1(f, exc._0))
                    ];
          
        }
    case /* Both */2 :
        var match$1 = inc._1;
        var inc$1 = inc._0;
        var exc$1 = split1d(match$1[0], match$1[1], toSepHigh);
        switch (exc$1.TAG | 0) {
          case /* Left */0 :
              return [
                      [Curry._1(f, inc$1)],
                      Caml_option.some(Curry._1(f, exc$1._0))
                    ];
          case /* Right */1 :
              return [
                      [
                        Curry._1(f, inc$1),
                        Curry._1(f, exc$1._0)
                      ],
                      undefined
                    ];
          case /* Both */2 :
              return [
                      [
                        Curry._1(f, inc$1),
                        Curry._1(f, exc$1._1)
                      ],
                      Caml_option.some(Curry._1(f, exc$1._0))
                    ];
          
        }
    
  }
}

function updX(cb, param) {
  return {
          low: Point3d.make(param[0], cb.low.y, cb.low.z),
          high: Point3d.make(param[1], cb.high.y, cb.high.z)
        };
}

function updY(cb, param) {
  return {
          low: Point3d.make(cb.low.x, param[0], cb.low.z),
          high: Point3d.make(cb.high.x, param[1], cb.high.z)
        };
}

function updZ(cb, param) {
  return {
          low: Point3d.make(cb.low.x, cb.low.y, param[0]),
          high: Point3d.make(cb.high.x, cb.high.y, param[1])
        };
}

function cut(cub, toRemove) {
  var match = partition1d(cub.low.x, cub.high.x, toRemove.low.x, toRemove.high.x, (function (param) {
          return updX(cub, param);
        }));
  var exc = match[1];
  var inc = match[0];
  if (exc === undefined) {
    return inc;
  }
  var match$1 = partition1d(exc.low.y, exc.high.y, toRemove.low.y, toRemove.high.y, (function (param) {
          return updY(exc, param);
        }));
  var exc$p = match$1[1];
  var inc$p = match$1[0];
  return inc.concat(exc$p !== undefined ? inc$p.concat(partition1d(exc$p.low.z, exc$p.high.z, toRemove.low.z, toRemove.high.z, (function (param) {
                            return updZ(exc$p, param);
                          }))[0]) : inc$p);
}

function sub(acc, $$new) {
  return acc.map(function (__x) {
                return cut(__x, $$new);
              }).flat();
}

function add(acc, $$new) {
  return [$$new].concat(sub(acc, $$new));
}

AoC.getInput("2021", "22", (function (input_) {
        var input = Tools.lines(input_).map(function (line) {
              var match = line.match(/^(on|off) x=(-?[0-9]+)..(-?[0-9]+),y=(-?[0-9]+)..(-?[0-9]+),z=(-?[0-9]+)..(-?[0-9]+)$/);
              if (match === null) {
                return Pervasives.failwith("bad line: " + line);
              }
              if (match.length !== 8) {
                return Pervasives.failwith("bad line: " + line);
              }
              var match$1 = match[1];
              switch (match$1) {
                case "off" :
                    var x1 = match[2];
                    var x2 = match[3];
                    var y1 = match[4];
                    var y2 = match[5];
                    var z1 = match[6];
                    var z2 = match[7];
                    return [
                            "off",
                            Point3d.make(parseInt(x1, 10), parseInt(y1, 10), parseInt(z1, 10)),
                            Point3d.make(parseInt(x2, 10), parseInt(y2, 10), parseInt(z2, 10))
                          ];
                case "on" :
                    var x1$1 = match[2];
                    var x2$1 = match[3];
                    var y1$1 = match[4];
                    var y2$1 = match[5];
                    var z1$1 = match[6];
                    var z2$1 = match[7];
                    return [
                            "on",
                            Point3d.make(parseInt(x1$1, 10), parseInt(y1$1, 10), parseInt(z1$1, 10)),
                            Point3d.make(parseInt(x2$1, 10), parseInt(y2$1, 10), parseInt(z2$1, 10))
                          ];
                default:
                  return Pervasives.failwith("bad line: " + line);
              }
            });
        var inRange = function (__x) {
          return Point3d.inRange(__x, Point3d.make(-50, -50, -50), Point3d.make(50, 50, 50));
        };
        console.log(Belt_Set.size(Tools.reduce(input.filter(function (param) {
                          if (inRange(param[1])) {
                            return inRange(param[2]);
                          } else {
                            return false;
                          }
                        }), Belt_Set.make(Point3d.Comparable), (function (acc, param) {
                        return (
                                  param[0] === "on" ? Belt_Set.mergeMany : Belt_Set.removeMany
                                )(acc, Point3d.range(param[1], param[2]));
                      }))));
        console.log(Tools.reduce(Tools.reduce(input, [], (function (acc, param) {
                          return (
                                    param[0] === "on" ? add : sub
                                  )(acc, {
                                      low: param[1],
                                      high: param[2]
                                    });
                        })).map(function (param) {
                      var high = param.high;
                      var low = param.low;
                      return ((high.x - low.x | 0) + 1 | 0) * ((high.y - low.y | 0) + 1 | 0) * ((high.z - low.z | 0) + 1 | 0);
                    }), 0, (function (prim0, prim1) {
                    return prim0 + prim1;
                  })));
        
      }));

var $$Set;

exports.$$Set = $$Set;
exports.split1d = split1d;
exports.partition1d = partition1d;
exports.updX = updX;
exports.updY = updY;
exports.updZ = updZ;
exports.cut = cut;
exports.sub = sub;
exports.add = add;
/*  Not a pure module */
