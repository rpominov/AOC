// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var AoC = require("../AoC.bs.js");
var Curry = require("rescript/lib/js/curry.js");
var Tools = require("../Tools.bs.js");
var Point3d = require("../Point3d.bs.js");
var Belt_List = require("rescript/lib/js/belt_List.js");
var Belt_MapString = require("rescript/lib/js/belt_MapString.js");
var Caml_splice_call = require("rescript/lib/js/caml_splice_call.js");

var angles = [
  0,
  90,
  180,
  270
];

var canonicalRotations = Belt_MapString.valuesToArray(Tools.reduce(angles.flatMap(function (x) {
              return angles.flatMap(function (y) {
                          return angles.map(function (z) {
                                      return [
                                              x,
                                              y,
                                              z
                                            ];
                                    });
                        });
            }), undefined, (function (acc, rotation) {
            return Belt_MapString.set(acc, [
                            Point3d.make(0, 0, 1),
                            Point3d.make(0, 1, 0),
                            Point3d.make(1, 0, 0)
                          ].map(function (p) {
                              return Point3d.toString(Point3d.rotate(p, rotation));
                            }).join(","), rotation);
          })));

function findVectorHelper(_acc, _existing, point) {
  while(true) {
    var existing = _existing;
    var acc = _acc;
    var ep = Tools.$$Array.get(existing, 0);
    if (ep === undefined) {
      return {
              TAG: /* Error */1,
              _0: acc
            };
    }
    var vector = Point3d.vector(point, ep);
    var key = Point3d.toString(vector);
    var count = Belt_MapString.getWithDefault(acc, key, 0) + 1 | 0;
    if (count >= 12) {
      return {
              TAG: /* Ok */0,
              _0: vector
            };
    }
    var acc$p = Belt_MapString.set(acc, key, count);
    var existing$p = Tools.rest(existing);
    _existing = existing$p;
    _acc = acc$p;
    continue ;
  };
}

function findTranslationVector(existing, $$new, rotation) {
  var v = Tools.reduce($$new, {
        TAG: /* Error */1,
        _0: undefined
      }, (function (acc, point) {
          if (acc.TAG === /* Ok */0) {
            return {
                    TAG: /* Ok */0,
                    _0: acc._0
                  };
          } else {
            return findVectorHelper(acc._0, existing, Point3d.rotate(point, rotation));
          }
        }));
  if (v.TAG === /* Ok */0) {
    return v._0;
  }
  
}

function findRotationAndTranslation(_rotationsOpt, existing, $$new) {
  while(true) {
    var rotationsOpt = _rotationsOpt;
    var rotations = rotationsOpt !== undefined ? rotationsOpt : canonicalRotations;
    var r = Tools.$$Array.get(rotations, 0);
    if (r === undefined) {
      return ;
    }
    var t = findTranslationVector(existing, $$new, r);
    if (t !== undefined) {
      return [
              r,
              t
            ];
    }
    _rotationsOpt = Tools.rest(rotations);
    continue ;
  };
}

function merge(existing, $$new) {
  var match = findRotationAndTranslation(undefined, existing, $$new);
  if (match === undefined) {
    return ;
  }
  var t = match[1];
  var r = match[0];
  var new$p = Tools.filterMap($$new, (function (p) {
          var p$p = Point3d.translate(Point3d.rotate(p, r), t);
          if (existing.some(function (param) {
                  return Point3d.eq(p$p, param);
                })) {
            return ;
          } else {
            return p$p;
          }
        }));
  return [
          t,
          existing.concat(new$p)
        ];
}

function mergeAll(_list, onMerged) {
  while(true) {
    var list = _list;
    if (!list) {
      return ;
    }
    var match = list.tl;
    var result = list.hd;
    if (!match) {
      return result;
    }
    var rest = match.tl;
    var s = match.hd;
    var match$1 = merge(result, s);
    if (match$1 !== undefined) {
      Curry._1(onMerged, match$1[0]);
      console.log("merged! " + Belt_List.length(rest).toString() + " remainig");
      _list = {
        hd: match$1[1],
        tl: rest
      };
      continue ;
    }
    _list = {
      hd: result,
      tl: Belt_List.concat(rest, {
            hd: s,
            tl: /* [] */0
          })
    };
    continue ;
  };
}

AoC.getInput("2021", "19", (function (input_) {
        var input = input_.split("\n\n").map(function (x) {
              return Tools.filterMap(Tools.rest(Tools.lines(x)), (function (line) {
                            return Point3d.fromArray(line.split(",").map(function (prim) {
                                            return parseInt(prim, 10);
                                          }));
                          }));
            });
        var translationVectors = [Point3d.make(0, 0, 0)];
        console.log(Tools.exn(mergeAll(Belt_List.fromArray(input), (function (v) {
                        translationVectors.push(v);
                        
                      }))).length);
        console.log(Caml_splice_call.spliceApply(Math.max, [translationVectors.flatMap(function (v) {
                        return translationVectors.map(function (param) {
                                    return Point3d.manhattanDistance(v, param);
                                  });
                      })]));
        
      }));

var $$Map;

var List;

exports.$$Map = $$Map;
exports.List = List;
exports.angles = angles;
exports.canonicalRotations = canonicalRotations;
exports.findVectorHelper = findVectorHelper;
exports.findTranslationVector = findTranslationVector;
exports.findRotationAndTranslation = findRotationAndTranslation;
exports.merge = merge;
exports.mergeAll = mergeAll;
/* canonicalRotations Not a pure module */
