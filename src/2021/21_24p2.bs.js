// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var AoC = require("../AoC.bs.js");
var Tools = require("../Tools.bs.js");
var Pervasives = require("rescript/lib/js/pervasives.js");

function strToReg(s) {
  switch (s) {
    case "w" :
        return /* W */3;
    case "x" :
        return /* X */0;
    case "y" :
        return /* Y */1;
    case "z" :
        return /* Z */2;
    default:
      return ;
  }
}

function strToRegExn(s) {
  var x = strToReg(s);
  if (x !== undefined) {
    return x;
  } else {
    return Pervasives.failwith("not a reg: " + s);
  }
}

function strToArg(s) {
  var r = strToReg(s);
  if (r !== undefined) {
    return {
            TAG: /* Reg */0,
            _0: r
          };
  }
  var n = Tools.string_to_float(s);
  if (n !== undefined) {
    return {
            TAG: /* Lit */1,
            _0: n
          };
  } else {
    return Pervasives.failwith("not an arg: " + s);
  }
}

function write(mem, reg, v) {
  switch (reg) {
    case /* X */0 :
        return {
                x: v,
                y: mem.y,
                z: mem.z,
                w: mem.w
              };
    case /* Y */1 :
        return {
                x: mem.x,
                y: v,
                z: mem.z,
                w: mem.w
              };
    case /* Z */2 :
        return {
                x: mem.x,
                y: mem.y,
                z: v,
                w: mem.w
              };
    case /* W */3 :
        return {
                x: mem.x,
                y: mem.y,
                z: mem.z,
                w: v
              };
    
  }
}

function read(mem, arg) {
  if (arg.TAG !== /* Reg */0) {
    return arg._0;
  }
  switch (arg._0) {
    case /* X */0 :
        return mem.x;
    case /* Y */1 :
        return mem.y;
    case /* Z */2 :
        return mem.z;
    case /* W */3 :
        return mem.w;
    
  }
}

function run(_debugOpt, _prog, _mem, _input) {
  while(true) {
    var debugOpt = _debugOpt;
    var input = _input;
    var mem = _mem;
    var prog = _prog;
    var debug = debugOpt !== undefined ? debugOpt : false;
    if (debug) {
      console.log(mem);
      console.log(Tools.$$Array.get(prog, 0));
    }
    var match = Tools.$$Array.get(prog, 0);
    if (match === undefined) {
      return [
              mem,
              prog
            ];
    }
    switch (match.TAG | 0) {
      case /* Inp */0 :
          if (input === undefined) {
            return [
                    mem,
                    prog
                  ];
          }
          _input = undefined;
          _mem = write(mem, match._0, input);
          _prog = Tools.rest(prog);
          _debugOpt = debug;
          continue ;
      case /* Mul */1 :
          var r = match._0;
          _mem = write(mem, r, read(mem, {
                    TAG: /* Reg */0,
                    _0: r
                  }) * read(mem, match._1));
          _prog = Tools.rest(prog);
          _debugOpt = debug;
          continue ;
      case /* Add */2 :
          var r$1 = match._0;
          _mem = write(mem, r$1, read(mem, {
                    TAG: /* Reg */0,
                    _0: r$1
                  }) + read(mem, match._1));
          _prog = Tools.rest(prog);
          _debugOpt = debug;
          continue ;
      case /* Div */3 :
          var r$2 = match._0;
          _mem = write(mem, r$2, Math.trunc(read(mem, {
                        TAG: /* Reg */0,
                        _0: r$2
                      }) / read(mem, match._1)));
          _prog = Tools.rest(prog);
          _debugOpt = debug;
          continue ;
      case /* Mod */4 :
          var r$3 = match._0;
          _mem = write(mem, r$3, read(mem, {
                    TAG: /* Reg */0,
                    _0: r$3
                  }) % read(mem, match._1));
          _prog = Tools.rest(prog);
          _debugOpt = debug;
          continue ;
      case /* Eql */5 :
          var r$4 = match._0;
          _mem = write(mem, r$4, read(mem, {
                    TAG: /* Reg */0,
                    _0: r$4
                  }) === read(mem, match._1) ? 1 : 0);
          _prog = Tools.rest(prog);
          _debugOpt = debug;
          continue ;
      
    }
  };
}

AoC.getInput("2021", "24", (function (input_) {
        var monadProgram = Tools.lines(input_).map(function (line) {
              var match = line.split(" ");
              var len = match.length;
              if (len !== 2) {
                if (len !== 3) {
                  return Pervasives.failwith("bad line: " + line);
                }
                var match$1 = match[0];
                switch (match$1) {
                  case "add" :
                      var a = match[1];
                      var b = match[2];
                      return {
                              TAG: /* Add */2,
                              _0: strToRegExn(a),
                              _1: strToArg(b)
                            };
                  case "div" :
                      var a$1 = match[1];
                      var b$1 = match[2];
                      return {
                              TAG: /* Div */3,
                              _0: strToRegExn(a$1),
                              _1: strToArg(b$1)
                            };
                  case "eql" :
                      var a$2 = match[1];
                      var b$2 = match[2];
                      return {
                              TAG: /* Eql */5,
                              _0: strToRegExn(a$2),
                              _1: strToArg(b$2)
                            };
                  case "mod" :
                      var a$3 = match[1];
                      var b$3 = match[2];
                      return {
                              TAG: /* Mod */4,
                              _0: strToRegExn(a$3),
                              _1: strToArg(b$3)
                            };
                  case "mul" :
                      var a$4 = match[1];
                      var b$4 = match[2];
                      return {
                              TAG: /* Mul */1,
                              _0: strToRegExn(a$4),
                              _1: strToArg(b$4)
                            };
                  default:
                    return Pervasives.failwith("bad line: " + line);
                }
              } else {
                var match$2 = match[0];
                if (match$2 !== "inp") {
                  return Pervasives.failwith("bad line: " + line);
                }
                var a$5 = match[1];
                return {
                        TAG: /* Inp */0,
                        _0: strToRegExn(a$5)
                      };
              }
            });
        for(var x1 = 3; x1 <= 9; ++x1){
          var match = run(undefined, monadProgram, {
                x: 0,
                y: 0,
                z: 0,
                w: 0
              }, x1);
          var prog = match[1];
          var mem = match[0];
          for(var x2 = 1; x2 <= 9; ++x2){
            var match$1 = run(undefined, prog, mem, x2);
            var prog$1 = match$1[1];
            var mem$1 = match$1[0];
            for(var x3 = 1; x3 <= 9; ++x3){
              var match$2 = run(undefined, prog$1, mem$1, x3);
              var prog$2 = match$2[1];
              var mem$2 = match$2[0];
              for(var x4 = 1; x4 <= 9; ++x4){
                var match$3 = run(undefined, prog$2, mem$2, x4);
                var prog$3 = match$3[1];
                var mem$3 = match$3[0];
                for(var x5 = 1; x5 <= 9; ++x5){
                  console.log("" + x1 + x2 + x3 + x4 + x5);
                  var match$4 = run(undefined, prog$3, mem$3, x5);
                  var prog$4 = match$4[1];
                  var mem$4 = match$4[0];
                  for(var x6 = 1; x6 <= 9; ++x6){
                    var match$5 = run(undefined, prog$4, mem$4, x6);
                    var prog$5 = match$5[1];
                    var mem$5 = match$5[0];
                    for(var x7 = 1; x7 <= 9; ++x7){
                      var match$6 = run(undefined, prog$5, mem$5, x7);
                      var prog$6 = match$6[1];
                      var mem$6 = match$6[0];
                      for(var x8 = 1; x8 <= 9; ++x8){
                        var match$7 = run(undefined, prog$6, mem$6, x8);
                        var prog$7 = match$7[1];
                        var mem$7 = match$7[0];
                        for(var x9 = 1; x9 <= 9; ++x9){
                          var match$8 = run(undefined, prog$7, mem$7, x9);
                          var prog$8 = match$8[1];
                          var mem$8 = match$8[0];
                          for(var x10 = 1; x10 <= 9; ++x10){
                            var match$9 = run(undefined, prog$8, mem$8, x10);
                            var mem$9 = match$9[0];
                            if (mem$9.z < 26 * 26 * 26 * 26) {
                              var prog$9 = match$9[1];
                              for(var x11 = 1; x11 <= 9; ++x11){
                                var match$10 = run(undefined, prog$9, mem$9, x11);
                                var mem$10 = match$10[0];
                                if (mem$10.z < 26 * 26 * 26) {
                                  var prog$10 = match$10[1];
                                  for(var x12 = 1; x12 <= 9; ++x12){
                                    var match$11 = run(undefined, prog$10, mem$10, x12);
                                    var mem$11 = match$11[0];
                                    if (mem$11.z >= 320 && mem$11.z <= 536 || mem$11.z <= 25) {
                                      var prog$11 = match$11[1];
                                      for(var x13 = 1; x13 <= 9; ++x13){
                                        var match$12 = run(undefined, prog$11, mem$11, x13);
                                        var mem$12 = match$12[0];
                                        if (mem$12.z >= 12 && mem$12.z <= 20) {
                                          var prog$12 = match$12[1];
                                          for(var x14 = 1; x14 <= 9; ++x14){
                                            var match$13 = run(undefined, prog$12, mem$12, x14);
                                            if (match$13[0].z === 0) {
                                              Pervasives.failwith([
                                                        x1,
                                                        x2,
                                                        x3,
                                                        x4,
                                                        x5,
                                                        x6,
                                                        x7,
                                                        x8,
                                                        x9,
                                                        x10,
                                                        x11,
                                                        x12,
                                                        x13,
                                                        x14
                                                      ].map(function (prim) {
                                                          return prim.toString();
                                                        }).join(""));
                                            }
                                            
                                          }
                                        }
                                        
                                      }
                                    }
                                    
                                  }
                                }
                                
                              }
                            }
                            
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        
      }));

exports.strToReg = strToReg;
exports.strToRegExn = strToRegExn;
exports.strToArg = strToArg;
exports.write = write;
exports.read = read;
exports.run = run;
/*  Not a pure module */
