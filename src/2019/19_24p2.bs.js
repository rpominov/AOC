// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var AoC = require("../AoC.bs.js");
var Point = require("../Point.bs.js");
var Tools = require("../Tools.bs.js");
var Navigation = require("../Navigation.bs.js");
var Pervasives = require("rescript/lib/js/pervasives.js");

var empty = Tools.range(0, 4).map(function (param) {
      return Tools.range(0, 4).map(function (param) {
                  return 0;
                });
    });

function get(state, z, x, y) {
  if (z < 0 || z >= state.length) {
    return 0;
  } else {
    return state[z][y][x];
  }
}

function inRange(__x) {
  return Point.inRange(__x, Point.make(0, 0), Point.make(4, 4));
}

function adjacentSum(state, z, x, y) {
  return Navigation.sumByDirection(function (direction) {
              var adj = Navigation.move(undefined, x, y, direction);
              if (adj.x === 2 && adj.y === 2) {
                return Tools.rangeSum(0, 4, (function (i) {
                              switch (direction) {
                                case /* N */0 :
                                    return get(state, z + 1 | 0, i, 0);
                                case /* S */1 :
                                    return get(state, z + 1 | 0, i, 4);
                                case /* E */2 :
                                    return get(state, z + 1 | 0, 0, i);
                                case /* W */3 :
                                    return get(state, z + 1 | 0, 4, i);
                                
                              }
                            }));
              }
              if (inRange(adj)) {
                return get(state, z, adj.x, adj.y);
              }
              var adj$p = Navigation.move(undefined, 2, 2, direction);
              return get(state, z - 1 | 0, adj$p.x, adj$p.y);
            });
}

function step(state) {
  return [
              [empty],
              state,
              [empty]
            ].flat().map(function (layer, z, state$p) {
              return layer.map(function (row, y, param) {
                          return row.map(function (v, x, param) {
                                      if (x === 2 && y === 2) {
                                        return 0;
                                      }
                                      var match = adjacentSum(state$p, z, x, y);
                                      if (match !== 1 && (match !== 2 || v !== 0)) {
                                        return 0;
                                      } else {
                                        return 1;
                                      }
                                    });
                        });
            });
}

AoC.getInput("2019", "24", (function (input) {
        var initial = Tools.lines(input).map(function (line) {
              return line.split("").map(function (x) {
                          switch (x) {
                            case "#" :
                                return 1;
                            case "." :
                                return 0;
                            default:
                              return Pervasives.failwith(x);
                          }
                        });
            });
        var __x = Tools.reduce(Tools.reduce(Tools.range(1, 200), [initial], (function (acc, param) {
                      return step(acc);
                    })).flat(2), 0, (function (prim0, prim1) {
                return prim0 + prim1 | 0;
              }));
        console.log("part 2:", __x);
        
      }));

var maxXY = 4;

var middle = 2;

exports.maxXY = maxXY;
exports.middle = middle;
exports.empty = empty;
exports.get = get;
exports.inRange = inRange;
exports.adjacentSum = adjacentSum;
exports.step = step;
/* empty Not a pure module */
