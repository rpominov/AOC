// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var AoC = require("../AoC.bs.js");
var Curry = require("rescript/lib/js/curry.js");
var Tools = require("../Tools.bs.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Belt_MapString = require("rescript/lib/js/belt_MapString.js");
var Caml_splice_call = require("rescript/lib/js/caml_splice_call.js");

var hexToB = Belt_MapString.fromArray([
      [
        "0",
        "0000"
      ],
      [
        "1",
        "0001"
      ],
      [
        "2",
        "0010"
      ],
      [
        "3",
        "0011"
      ],
      [
        "4",
        "0100"
      ],
      [
        "5",
        "0101"
      ],
      [
        "6",
        "0110"
      ],
      [
        "7",
        "0111"
      ],
      [
        "8",
        "1000"
      ],
      [
        "9",
        "1001"
      ],
      [
        "A",
        "1010"
      ],
      [
        "B",
        "1011"
      ],
      [
        "C",
        "1100"
      ],
      [
        "D",
        "1101"
      ],
      [
        "E",
        "1110"
      ],
      [
        "F",
        "1111"
      ]
    ]);

function take(seq, n) {
  if (seq.length < n) {
    Pervasives.failwith("" + 26 + ": take(" + seq + ", " + n + ")");
  }
  return [
          seq.slice(0, n),
          seq.slice(n)
        ];
}

function getHeader(seq) {
  var match = take(seq, 3);
  var match$1 = take(match[1], 3);
  return [
          {
            ver: Tools.string_to_int_radix(match[0], 2),
            id: Tools.string_to_int_radix(match$1[0], 2)
          },
          match$1[1]
        ];
}

function getLength(seq) {
  var match = take(seq, 1);
  var seq1 = match[1];
  switch (match[0]) {
    case "0" :
        var match$1 = take(seq1, 15);
        return [
                {
                  TAG: /* Bytes */0,
                  _0: Tools.string_to_int_radix(match$1[0], 2)
                },
                match$1[1]
              ];
    case "1" :
        var match$2 = take(seq1, 11);
        return [
                {
                  TAG: /* Packets */1,
                  _0: Tools.string_to_int_radix(match$2[0], 2)
                },
                match$2[1]
              ];
    default:
      return Pervasives.failwith(seq);
  }
}

function getLiteralBlocks(_acc, _seq) {
  while(true) {
    var seq = _seq;
    var acc = _acc;
    var match = take(seq, 1);
    var match$1 = take(match[1], 4);
    var seq$1 = match$1[1];
    var acc1 = acc.concat([match$1[0]]);
    switch (match[0]) {
      case "0" :
          return [
                  acc1,
                  seq$1
                ];
      case "1" :
          _seq = seq$1;
          _acc = acc1;
          continue ;
      default:
        return Pervasives.failwith(seq$1);
    }
  };
}

function getLiteral(seq) {
  var match = getLiteralBlocks([], seq);
  return [
          Tools.string_to_int_radix(match[0].join(""), 2),
          match[1]
        ];
}

function parsePacket(seq) {
  var match = getHeader(seq);
  var seq$1 = match[1];
  var header = match[0];
  if (header.id === 4) {
    var match$1 = getLiteral(seq$1);
    return [
            {
              TAG: /* Literal */0,
              header: header,
              value: match$1[0]
            },
            match$1[1]
          ];
  }
  var match$2 = getLength(seq$1);
  var seq$2 = match$2[1];
  var l = match$2[0];
  var isExhausted;
  if (l.TAG === /* Bytes */0) {
    var x = l._0;
    isExhausted = (function (curSeq, param) {
        return (seq$2.length - curSeq.length | 0) === x;
      });
  } else {
    var x$1 = l._0;
    isExhausted = (function (param, curSubPackets) {
        return curSubPackets.length === x$1;
      });
  }
  var lastSeq = seq$2;
  var subPackets = [];
  while(!Curry._2(isExhausted, lastSeq, subPackets)) {
    var match$3 = parsePacket(lastSeq);
    subPackets.push(match$3[0]);
    lastSeq = match$3[1];
  };
  return [
          {
            TAG: /* Operator */1,
            header: header,
            length: l,
            subPackets: subPackets
          },
          lastSeq
        ];
}

function packetToString(packet) {
  if (packet.TAG === /* Literal */0) {
    return String(packet.value);
  }
  var match = packet.header.id;
  var name;
  switch (match) {
    case 0 :
        name = "sum";
        break;
    case 1 :
        name = "mul";
        break;
    case 2 :
        name = "min";
        break;
    case 3 :
        name = "max";
        break;
    case 4 :
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
    case 5 :
        name = "gt";
        break;
    case 6 :
        name = "lt";
        break;
    case 7 :
        name = "eq";
        break;
    default:
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
  }
  return name + "(" + packet.subPackets.map(packetToString).join(", ") + ")";
}

function sumVersions(packet) {
  if (packet.TAG === /* Literal */0) {
    return packet.header.ver;
  } else {
    return packet.header.ver + Tools.reduce(packet.subPackets.map(sumVersions), 0, (function (prim0, prim1) {
                  return prim0 + prim1 | 0;
                })) | 0;
  }
}

function execute(packet) {
  if (packet.TAG === /* Literal */0) {
    return packet.value;
  }
  var match = packet.header.id;
  var match$1 = packet.subPackets.map(execute);
  switch (match) {
    case 0 :
        return Tools.reduce(match$1, 0, (function (prim0, prim1) {
                      return prim0 + prim1;
                    }));
    case 1 :
        return Tools.reduce(match$1, 1, (function (prim0, prim1) {
                      return prim0 * prim1;
                    }));
    case 2 :
        return Caml_splice_call.spliceApply(Math.min, [match$1]);
    case 3 :
        return Caml_splice_call.spliceApply(Math.max, [match$1]);
    case 4 :
        throw {
              RE_EXN_ID: "Not_found",
              Error: new Error()
            };
    case 5 :
        if (match$1.length !== 2) {
          throw {
                RE_EXN_ID: "Not_found",
                Error: new Error()
              };
        }
        var f = match$1[0];
        var s = match$1[1];
        if (f > s) {
          return 1;
        } else {
          return 0;
        }
    case 6 :
        if (match$1.length !== 2) {
          throw {
                RE_EXN_ID: "Not_found",
                Error: new Error()
              };
        }
        var f$1 = match$1[0];
        var s$1 = match$1[1];
        if (f$1 < s$1) {
          return 1;
        } else {
          return 0;
        }
    case 7 :
        if (match$1.length !== 2) {
          throw {
                RE_EXN_ID: "Not_found",
                Error: new Error()
              };
        }
        var f$2 = match$1[0];
        var s$2 = match$1[1];
        if (f$2 === s$2) {
          return 1;
        } else {
          return 0;
        }
    default:
      throw {
            RE_EXN_ID: "Not_found",
            Error: new Error()
          };
  }
}

AoC.getInput("2021", "16", (function (input_) {
        var input = Caml_splice_call.spliceObjApply("", "concat", [Tools.filterMap(input_.split(""), (function (param) {
                      return Belt_MapString.get(hexToB, param);
                    }))]);
        var match = parsePacket(input);
        var pack = match[0];
        console.log(packetToString(pack));
        console.log(sumVersions(pack));
        console.log(execute(pack));
        
      }));

var $$Map;

exports.$$Map = $$Map;
exports.hexToB = hexToB;
exports.take = take;
exports.getHeader = getHeader;
exports.getLength = getLength;
exports.getLiteralBlocks = getLiteralBlocks;
exports.getLiteral = getLiteral;
exports.parsePacket = parsePacket;
exports.packetToString = packetToString;
exports.sumVersions = sumVersions;
exports.execute = execute;
/* hexToB Not a pure module */
