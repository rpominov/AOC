// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var AoC = require("../AoC.bs.js");
var Tools = require("../Tools.bs.js");
var Belt_Id = require("rescript/lib/js/belt_Id.js");
var Belt_Set = require("rescript/lib/js/belt_Set.js");
var Pervasives = require("rescript/lib/js/pervasives.js");
var Caml_splice_call = require("rescript/lib/js/caml_splice_call.js");

function cmp(param, param$1) {
  var c = param[0] - param$1[0] | 0;
  if (c !== 0) {
    return c;
  } else {
    return param[1] - param$1[1] | 0;
  }
}

var PointComparator = Belt_Id.MakeComparable({
      cmp: cmp
    });

function foldBy(points, fold) {
  return Belt_Set.fromArray(Belt_Set.toArray(points).map(function (point) {
                  if (fold.TAG === /* XFold */0) {
                    var x = point[0];
                    var fx = fold._0;
                    if (x < fx) {
                      return point;
                    } else {
                      return [
                              (fx << 1) - x | 0,
                              point[1]
                            ];
                    }
                  }
                  var y = point[1];
                  var fy = fold._0;
                  if (y < fy) {
                    return point;
                  } else {
                    return [
                            point[0],
                            (fy << 1) - y | 0
                          ];
                  }
                }), PointComparator);
}

AoC.getInput("2021", "13", (function (input_) {
        var match = input_.split("\n\n");
        var match$1;
        if (match.length !== 2) {
          match$1 = Pervasives.failwith("bad input");
        } else {
          var a = match[0];
          var b = match[1];
          match$1 = [
            a,
            b
          ];
        }
        var dots = Belt_Set.fromArray(Tools.lines(match$1[0]).map(function (line) {
                  var match = line.split(",").map(function (prim) {
                        return parseInt(prim, 10);
                      });
                  if (match.length !== 2) {
                    return Pervasives.failwith("bad line:" + line);
                  }
                  var x = match[0];
                  var y = match[1];
                  return [
                          x,
                          y
                        ];
                }), PointComparator);
        var folds = Tools.lines(match$1[1]).map(function (line) {
              var match = line.split("=");
              if (match.length !== 2) {
                return Pervasives.failwith("bad line:" + line);
              }
              var match$1 = match[0];
              switch (match$1) {
                case "fold along x" :
                    var x = match[1];
                    return {
                            TAG: /* XFold */0,
                            _0: parseInt(x, 10)
                          };
                case "fold along y" :
                    var y = match[1];
                    return {
                            TAG: /* YFold */1,
                            _0: parseInt(y, 10)
                          };
                default:
                  return Pervasives.failwith("bad line:" + line);
              }
            });
        console.log(Belt_Set.toArray(foldBy(dots, Tools.exn(Tools.$$Array.get(folds, 0)))).length);
        var finalDots = Tools.reduce(folds, dots, foldBy);
        var maxX = Caml_splice_call.spliceApply(Math.max, [Belt_Set.toArray(finalDots).map(function (param) {
                    return param[0];
                  })]);
        var maxY = Caml_splice_call.spliceApply(Math.max, [Belt_Set.toArray(finalDots).map(function (param) {
                    return param[1];
                  })]);
        for(var y = 0; y <= maxY; ++y){
          console.log(Tools.range(0, maxX).map((function(y){
                    return function (x) {
                      if (Belt_Set.has(finalDots, [
                              x,
                              y
                            ])) {
                        return "8";
                      } else {
                        return " ";
                      }
                    }
                    }(y))).join(""));
        }
        
      }));

var $$Set;

exports.$$Set = $$Set;
exports.PointComparator = PointComparator;
exports.foldBy = foldBy;
/* PointComparator Not a pure module */
